<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#1a1a2e">
<meta name="apple-mobile-web-app-capable" content="yes">
<link rel="manifest" href="manifest.json">
<title>Zippy Voice</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #1a1a2e; color: #e0e0e0; height: 100vh;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  overflow: hidden; -webkit-user-select: none; user-select: none;
}
.top-btn {
  position: fixed; top: 16px; width: 44px; height: 44px;
  background: rgba(255,255,255,0.1); border: none; border-radius: 50%;
  color: #aaa; font-size: 20px; cursor: pointer; z-index: 100;
  display: flex; align-items: center; justify-content: center;
}
#reset-btn { left: 16px; }
#settings-btn { right: 16px; }
#mic-btn {
  width: 180px; height: 180px; border-radius: 50%; border: none; cursor: pointer;
  transition: background 0.3s, box-shadow 0.3s, transform 0.1s;
  display: flex; align-items: center; justify-content: center;
  -webkit-tap-highlight-color: transparent;
}
#mic-btn svg { width: 72px; height: 72px; fill: #fff; }
#mic-btn.idle { background: #2563eb; }
#mic-btn.recording { background: #dc2626; animation: pulse-red 1s infinite; transform: scale(1.05); }
#mic-btn.sending { background: #d97706; }
#mic-btn.playing { background: #16a34a; animation: pulse-green 1.5s infinite; }
@keyframes pulse-red {
  0% { box-shadow: 0 0 0 0 rgba(220,38,38,0.6); }
  70% { box-shadow: 0 0 0 35px rgba(220,38,38,0); }
  100% { box-shadow: 0 0 0 0 rgba(220,38,38,0); }
}
@keyframes pulse-green {
  0% { box-shadow: 0 0 0 0 rgba(22,163,74,0.5); }
  70% { box-shadow: 0 0 0 25px rgba(22,163,74,0); }
  100% { box-shadow: 0 0 0 0 rgba(22,163,74,0); }
}
#status { margin-top: 32px; font-size: 18px; color: #999; text-align: center; min-height: 28px; }
#transcript {
  margin-top: 16px; font-size: 14px; color: #666; text-align: center;
  max-width: 85%; min-height: 20px; word-wrap: break-word;
}
#timer { margin-top: 8px; font-size: 24px; color: #dc2626; font-variant-numeric: tabular-nums; min-height: 30px; }
/* Settings */
#settings-modal {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.8);
  z-index: 200; align-items: center; justify-content: center;
}
#settings-modal.open { display: flex; }
#settings-panel {
  background: #16213e; border-radius: 16px; padding: 28px;
  width: 90%; max-width: 400px;
}
#settings-panel h2 { color: #fff; margin-bottom: 20px; }
#settings-panel label { display: block; color: #aaa; font-size: 13px; margin-top: 14px; margin-bottom: 4px; }
#settings-panel input {
  width: 100%; padding: 10px; border: 1px solid #333;
  border-radius: 8px; background: #0f3460; color: #fff; font-size: 15px;
}
.btn-row { margin-top: 24px; display: flex; gap: 12px; }
.btn-row button { flex: 1; padding: 12px; border: none; border-radius: 8px; font-size: 15px; cursor: pointer; }
#save-btn { background: #2563eb; color: #fff; }
#cancel-btn { background: #444; color: #fff; }
</style>
</head>
<body>
<button id="reset-btn" class="top-btn">üîÑ</button>
<button id="settings-btn" class="top-btn">‚öôÔ∏è</button>

<button id="mic-btn" class="idle">
  <svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5zm6 6c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
</button>

<div id="status">Tap to talk</div>
<div id="timer"></div>
<div id="transcript"></div>

<div id="settings-modal">
  <div id="settings-panel">
    <h2>‚ö° Settings</h2>
    <label for="cfg-url">Server URL (blank = same origin)</label>
    <input id="cfg-url" type="url" placeholder="Leave blank for default">
    <label for="cfg-token">Auth Token</label>
    <input id="cfg-token" type="password" placeholder="Gateway token">
    <div class="btn-row">
      <button id="cancel-btn">Cancel</button>
      <button id="save-btn">Save</button>
    </div>
  </div>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ Config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DEFAULTS = { url: '', token: '' };
function loadConfig() {
  try { return { ...DEFAULTS, ...JSON.parse(localStorage.getItem('zv_config')) }; }
  catch { return { ...DEFAULTS }; }
}
function saveConfig(cfg) { localStorage.setItem('zv_config', JSON.stringify(cfg)); }
let config = loadConfig();

// ‚îÄ‚îÄ‚îÄ DOM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const micBtn = document.getElementById('mic-btn');
const statusEl = document.getElementById('status');
const timerEl = document.getElementById('timer');
const transcriptEl = document.getElementById('transcript');

// ‚îÄ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('settings-btn').addEventListener('click', () => {
  document.getElementById('cfg-url').value = config.url;
  document.getElementById('cfg-token').value = config.token;
  document.getElementById('settings-modal').classList.add('open');
});
document.getElementById('cancel-btn').addEventListener('click', () => {
  document.getElementById('settings-modal').classList.remove('open');
});
document.getElementById('save-btn').addEventListener('click', () => {
  config.url = document.getElementById('cfg-url').value.replace(/\/+$/, '') || '';
  config.token = document.getElementById('cfg-token').value;
  saveConfig(config);
  document.getElementById('settings-modal').classList.remove('open');
});

// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let state = 'idle'; // idle | recording | sending | playing
let mediaRecorder = null;
let audioChunks = [];
let recordingStart = 0;
let timerInterval = null;
let wakeLock = null;
let isSpeaking = false;
let speakResolve = null;

function setState(newState, msg) {
  state = newState;
  micBtn.className = newState;
  statusEl.textContent = msg || {
    idle: 'Tap to talk',
    recording: 'Recording ‚Äî tap to send',
    sending: 'Sending to Zippy...',
    playing: 'Tap anywhere to stop'
  }[newState];
  if (newState !== 'recording') {
    timerEl.textContent = '';
    clearInterval(timerInterval);
  }
}

// ‚îÄ‚îÄ‚îÄ Wake Lock ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function requestWakeLock() {
  try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch {}
}

// ‚îÄ‚îÄ‚îÄ Recording ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioChunks = [];
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };
    mediaRecorder.onstop = () => {
      stream.getTracks().forEach(t => t.stop());
    };
    mediaRecorder.start(100); // Collect in 100ms chunks
    recordingStart = Date.now();
    setState('recording');
    requestWakeLock();

    // Timer display
    timerInterval = setInterval(() => {
      const secs = Math.floor((Date.now() - recordingStart) / 1000);
      timerEl.textContent = `${Math.floor(secs / 60)}:${(secs % 60).toString().padStart(2, '0')}`;
    }, 200);
  } catch (e) {
    setState('idle', 'Mic permission denied');
  }
}

async function stopAndSend() {
  if (!mediaRecorder || mediaRecorder.state !== 'recording') return;
  clearInterval(timerInterval);

  return new Promise((resolve) => {
    mediaRecorder.onstop = () => {
      mediaRecorder.stream.getTracks().forEach(t => t.stop());
      resolve();
    };
    mediaRecorder.stop();
  }).then(sendAudio);
}

async function sendAudio() {
  const blob = new Blob(audioChunks, { type: 'audio/webm' });
  audioChunks = [];

  if (blob.size < 1000) {
    setState('idle', 'Too short ‚Äî tap and talk');
    return;
  }

  setState('sending');
  transcriptEl.textContent = '';

  const maxRetries = 3;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const formData = new FormData();
      formData.append('audio', blob, 'voice.webm');
      formData.append('token', config.token);

      if (attempt > 1) setState('sending', `Retrying... (${attempt}/${maxRetries})`);

      const baseUrl = config.url || window.location.origin;
      const resp = await fetch(`${baseUrl}/api/voice-send`, {
        method: 'POST',
        body: formData
      });

      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();

      if (data.error) {
        setState('idle', data.error);
        return;
      }

      // Show transcript
      transcriptEl.textContent = data.transcript || '';

      // Play voice response
      const voiceReply = data.reply || 'No response';
      const fullReply = data.fullReply || voiceReply;
      setState('playing');
      transcriptEl.textContent = fullReply.substring(0, 300) + (fullReply.length > 300 ? '...' : '');
      await speak(voiceReply);
      setState('idle');
      return; // success, done
    } catch (err) {
      console.error(`Attempt ${attempt} failed:`, err);
      if (attempt < maxRetries) {
        await new Promise(r => setTimeout(r, 2000)); // wait 2s before retry
      } else {
        await speak('Could not reach Zippy after multiple tries.');
        setState('idle', 'Connection failed ‚Äî check WiFi/Tailscale');
      }
    }
  }
}

// ‚îÄ‚îÄ‚îÄ TTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function speak(text) {
  return new Promise((resolve) => {
    if (!window.speechSynthesis) { resolve(); return; }
    speechSynthesis.cancel();
    isSpeaking = true;
    speakResolve = resolve;
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'en-US';
    utterance.rate = 1.0;
    const voices = speechSynthesis.getVoices();
    const preferred = voices.find(v =>
      v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural'))
    ) || voices.find(v => v.lang.startsWith('en'));
    if (preferred) utterance.voice = preferred;
    utterance.onend = () => { isSpeaking = false; speakResolve = null; resolve(); };
    utterance.onerror = () => { isSpeaking = false; speakResolve = null; resolve(); };
    speechSynthesis.speak(utterance);
  });
}
function stopSpeaking() {
  if (isSpeaking) {
    speechSynthesis.cancel();
    isSpeaking = false;
    if (speakResolve) { speakResolve(); speakResolve = null; }
  }
}
if (window.speechSynthesis) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
}

// ‚îÄ‚îÄ‚îÄ Main Button ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
micBtn.addEventListener('click', () => {
  if (state === 'idle') {
    if (!config.token) { document.getElementById('settings-btn').click(); return; }
    startRecording();
  } else if (state === 'recording') {
    stopAndSend();
  } else if (state === 'playing') {
    stopSpeaking();
    setState('idle');
  }
});

// Tap anywhere to stop playback
document.addEventListener('touchstart', (e) => {
  if (state === 'playing' && !e.target.closest('#settings-modal') && !e.target.classList.contains('top-btn')) {
    e.preventDefault();
    stopSpeaking();
    setState('idle');
  }
}, { passive: false });

// ‚îÄ‚îÄ‚îÄ Hard Reset ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('reset-btn').addEventListener('click', async () => {
  if (!confirm('Reset app?')) return;
  const regs = await navigator.serviceWorker?.getRegistrations() || [];
  for (const r of regs) await r.unregister();
  const keys = await caches?.keys() || [];
  for (const k of keys) await caches.delete(k);
  window.location.reload(true);
});

// ‚îÄ‚îÄ‚îÄ Service Worker ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js').catch(() => {});

document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible' && state !== 'idle') requestWakeLock();
});
</script>
</body>
</html>
